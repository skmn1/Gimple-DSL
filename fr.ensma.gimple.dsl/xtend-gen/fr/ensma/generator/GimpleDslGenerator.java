/**
 * generated by Xtext 2.25.0
 */
package fr.ensma.generator;

import com.google.common.collect.Iterables;
import com.google.common.io.CharStreams;
import fr.ensma.gimpleDsl.FunctionDef;
import fr.ensma.gimpleDsl.Instruction;
import fr.ensma.gimpleDsl.TAC;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class GimpleDslGenerator implements IGimpleGenerator {
  @Override
  public void doGenerate(final ResourceSet rs, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    try {
      final File file = new File("C:\\Users\\kamnis\\Desktop\\runtime-New_configuration\\gimple\\gimple.melodymodeller");
      final List<String> fileLines = CharStreams.readLines(new FileReader(file));
      final Function1<Resource, Iterable<TAC>> _function = (Resource r) -> {
        return Iterables.<TAC>filter(IteratorExtensions.<EObject>toIterable(r.getAllContents()), TAC.class);
      };
      final Iterable<TAC> model = Iterables.<TAC>concat(ListExtensions.<Resource, Iterable<TAC>>map(rs.getResources(), _function));
      CharSequence content = this.compile(model);
      String str = "";
      for (final String line : fileLines) {
        {
          String _str = str;
          str = (_str + (line + "\n"));
          boolean _contains = line.contains("name=\"Thread\" timeBudgetUnit=\"ms\">");
          if (_contains) {
            String _str_1 = str;
            str = (_str_1 + content);
          }
        }
      }
      final FileWriter writer = new FileWriter(file);
      writer.write(str);
      writer.flush();
      writer.close();
      fsa.generateFile("capella.txt", content);
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Override
  public void afterGenerate(final Resource input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
  }
  
  @Override
  public void beforeGenerate(final Resource input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
  }
  
  @Override
  public void doGenerate(final Resource input, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
  }
  
  public CharSequence compile(final Iterable<TAC> tacs) {
    StringConcatenation _builder = new StringConcatenation();
    {
      for(final TAC tac : tacs) {
        {
          EList<FunctionDef> _functionDef = tac.getFunctionDef();
          for(final FunctionDef functionDef : _functionDef) {
            String _name = functionDef.getName().getName();
            String _plus = ("\t\t\t\t\t<ownedExtensions xsi:type=\"deployment:AADLFunction\" id=\"654c1232-49f0-48dc-8f4e-fcb2ef42f336\" name=\"" + _name);
            String _plus_1 = (_plus + "\">\n");
            _builder.append(_plus_1);
            _builder.newLineIfNotEmpty();
            {
              EList<Instruction> _instruction = functionDef.getCodeBlock().getInstruction();
              for(final Instruction instruction : _instruction) {
                String _name_1 = instruction.getFunctionCall().getCalledFunction().getName();
                String _plus_2 = ("\t\t\t\t\t\t<ownedExtensions xsi:type=\"deployment:AADLFunction\" id=\"654c1232-49f0-48dc-8f4e-fcb2ef42f336\" name=\"" + _name_1);
                String _plus_3 = (_plus_2 + "\"/>\n");
                _builder.append(_plus_3);
                _builder.newLineIfNotEmpty();
              }
            }
            _builder.append("\t\t\t\t\t</ownedExtensions>\n");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
}
