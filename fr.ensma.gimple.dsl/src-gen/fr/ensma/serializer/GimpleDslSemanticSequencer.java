/*
 * generated by Xtext 2.25.0
 */
package fr.ensma.serializer;

import com.google.inject.Inject;
import fr.ensma.gimpleDsl.Argument;
import fr.ensma.gimpleDsl.ArithmeticOperation;
import fr.ensma.gimpleDsl.AssignOperation;
import fr.ensma.gimpleDsl.BinaryOperation;
import fr.ensma.gimpleDsl.CodeBlock;
import fr.ensma.gimpleDsl.CommentLine;
import fr.ensma.gimpleDsl.DataType;
import fr.ensma.gimpleDsl.DebugTag;
import fr.ensma.gimpleDsl.Declaration;
import fr.ensma.gimpleDsl.ExpressionTemporarie;
import fr.ensma.gimpleDsl.Function;
import fr.ensma.gimpleDsl.FunctionArgument;
import fr.ensma.gimpleDsl.FunctionCall;
import fr.ensma.gimpleDsl.FunctionDef;
import fr.ensma.gimpleDsl.FunctionParam;
import fr.ensma.gimpleDsl.GimpleDslPackage;
import fr.ensma.gimpleDsl.Goto;
import fr.ensma.gimpleDsl.Instruction;
import fr.ensma.gimpleDsl.Label;
import fr.ensma.gimpleDsl.LabelDef;
import fr.ensma.gimpleDsl.LocalVariable;
import fr.ensma.gimpleDsl.LogicalOperation;
import fr.ensma.gimpleDsl.Struct;
import fr.ensma.gimpleDsl.StructVariableCall;
import fr.ensma.gimpleDsl.SwitchCase;
import fr.ensma.gimpleDsl.SwitchDefaultCase;
import fr.ensma.gimpleDsl.SwitchLabel;
import fr.ensma.gimpleDsl.SwitchLabelDef;
import fr.ensma.gimpleDsl.SwitchStatment;
import fr.ensma.gimpleDsl.TAC;
import fr.ensma.gimpleDsl.TempVariable;
import fr.ensma.gimpleDsl.VariableCall;
import fr.ensma.gimpleDsl.VariableDeclaration;
import fr.ensma.services.GimpleDslGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GimpleDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GimpleDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GimpleDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GimpleDslPackage.ARGUMENT:
				sequence_Argument(context, (Argument) semanticObject); 
				return; 
			case GimpleDslPackage.ARITHMETIC_OPERATION:
				sequence_ArithmeticOperation(context, (ArithmeticOperation) semanticObject); 
				return; 
			case GimpleDslPackage.ASSIGN_OPERATION:
				sequence_AssignOperation(context, (AssignOperation) semanticObject); 
				return; 
			case GimpleDslPackage.BINARY_OPERATION:
				sequence_BinaryOperation(context, (BinaryOperation) semanticObject); 
				return; 
			case GimpleDslPackage.CODE_BLOCK:
				sequence_CodeBlock(context, (CodeBlock) semanticObject); 
				return; 
			case GimpleDslPackage.COMMENT_LINE:
				sequence_CommentLine(context, (CommentLine) semanticObject); 
				return; 
			case GimpleDslPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case GimpleDslPackage.DEBUG_TAG:
				sequence_DebugTag(context, (DebugTag) semanticObject); 
				return; 
			case GimpleDslPackage.DECLARATION:
				sequence_ConstantDelaration(context, (Declaration) semanticObject); 
				return; 
			case GimpleDslPackage.EXPRESSION_TEMPORARIE:
				sequence_ExpressionTemporarie(context, (ExpressionTemporarie) semanticObject); 
				return; 
			case GimpleDslPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case GimpleDslPackage.FUNCTION_ARGUMENT:
				sequence_FunctionArgument(context, (FunctionArgument) semanticObject); 
				return; 
			case GimpleDslPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case GimpleDslPackage.FUNCTION_DEF:
				sequence_FunctionDef(context, (FunctionDef) semanticObject); 
				return; 
			case GimpleDslPackage.FUNCTION_PARAM:
				sequence_FunctionParam(context, (FunctionParam) semanticObject); 
				return; 
			case GimpleDslPackage.GOTO:
				sequence_Goto(context, (Goto) semanticObject); 
				return; 
			case GimpleDslPackage.INSTRUCTION:
				sequence_Instruction(context, (Instruction) semanticObject); 
				return; 
			case GimpleDslPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case GimpleDslPackage.LABEL_DEF:
				sequence_LabelDef(context, (LabelDef) semanticObject); 
				return; 
			case GimpleDslPackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case GimpleDslPackage.LOGICAL_OPERATION:
				if (rule == grammarAccess.getIfRule()) {
					sequence_If_LogicalOperation(context, (LogicalOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBooleanExpressionRule()
						|| rule == grammarAccess.getLogicalOperationRule()) {
					sequence_LogicalOperation(context, (LogicalOperation) semanticObject); 
					return; 
				}
				else break;
			case GimpleDslPackage.STRUCT:
				sequence_Struct(context, (Struct) semanticObject); 
				return; 
			case GimpleDslPackage.STRUCT_VARIABLE_CALL:
				sequence_StructVariableCall(context, (StructVariableCall) semanticObject); 
				return; 
			case GimpleDslPackage.SWITCH_CASE:
				sequence_SwitchCase(context, (SwitchCase) semanticObject); 
				return; 
			case GimpleDslPackage.SWITCH_DEFAULT_CASE:
				sequence_SwitchDefaultCase(context, (SwitchDefaultCase) semanticObject); 
				return; 
			case GimpleDslPackage.SWITCH_LABEL:
				sequence_SwitchLabel(context, (SwitchLabel) semanticObject); 
				return; 
			case GimpleDslPackage.SWITCH_LABEL_DEF:
				sequence_SwitchLabelDef(context, (SwitchLabelDef) semanticObject); 
				return; 
			case GimpleDslPackage.SWITCH_STATMENT:
				sequence_SwitchStatment(context, (SwitchStatment) semanticObject); 
				return; 
			case GimpleDslPackage.TAC:
				sequence_TAC(context, (TAC) semanticObject); 
				return; 
			case GimpleDslPackage.TEMP_VARIABLE:
				sequence_TempVariable(context, (TempVariable) semanticObject); 
				return; 
			case GimpleDslPackage.VARIABLE_CALL:
				sequence_VariableCall(context, (VariableCall) semanticObject); 
				return; 
			case GimpleDslPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Argument returns Argument
	 *
	 * Constraint:
	 *     name=ID?
	 */
	protected void sequence_Argument(ISerializationContext context, Argument semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticOperation returns ArithmeticOperation
	 *
	 * Constraint:
	 *     {ArithmeticOperation}
	 */
	protected void sequence_ArithmeticOperation(ISerializationContext context, ArithmeticOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignOperation returns AssignOperation
	 *
	 * Constraint:
	 *     (
	 *         (name=VariableCall | name=TempVariable | name=StructVariableCall) 
	 *         cast?=Cast? 
	 *         vcall+=VariableCall? 
	 *         (
	 *             (tempVariable+=TempVariable | functionCall+=FunctionCall | arithmeticOperation+=ArithmeticOperation | binaryOperation+=BinaryOperation)? 
	 *             vcall+=VariableCall?
	 *         )*
	 *     )
	 */
	protected void sequence_AssignOperation(ISerializationContext context, AssignOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BinaryOperation returns BinaryOperation
	 *
	 * Constraint:
	 *     {BinaryOperation}
	 */
	protected void sequence_BinaryOperation(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CodeBlock returns CodeBlock
	 *
	 * Constraint:
	 *     instruction+=Instruction*
	 */
	protected void sequence_CodeBlock(ISerializationContext context, CodeBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CommentLine returns CommentLine
	 *
	 * Constraint:
	 *     name=SL_SC_COMMENT
	 */
	protected void sequence_CommentLine(ISerializationContext context, CommentLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.COMMENT_LINE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.COMMENT_LINE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommentLineAccess().getNameSL_SC_COMMENTTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstantDelaration returns Declaration
	 *
	 * Constraint:
	 *     name=LocalVariable
	 */
	protected void sequence_ConstantDelaration(ISerializationContext context, Declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantDelarationAccess().getNameLocalVariableParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Cast returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     (name='float' | name='int' | name='uint8_t' | name='int16_t' | name='char')
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DebugTag returns DebugTag
	 *
	 * Constraint:
	 *     name=DEBUG_BEGIN
	 */
	protected void sequence_DebugTag(ISerializationContext context, DebugTag semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.DEBUG_TAG__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.DEBUG_TAG__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDebugTagAccess().getNameDEBUG_BEGINTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionTemporarie returns ExpressionTemporarie
	 *
	 * Constraint:
	 *     (tempVariableL+=TempVariable tempVariableR1+=TempVariable? (arithmeticOperation+=ArithmeticOperation tempVariableR2+=TempVariable?)*)
	 */
	protected void sequence_ExpressionTemporarie(ISerializationContext context, ExpressionTemporarie semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionArgument returns FunctionArgument
	 *
	 * Constraint:
	 *     name=Argument
	 */
	protected void sequence_FunctionArgument(ISerializationContext context, FunctionArgument semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.FUNCTION_ARGUMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.FUNCTION_ARGUMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionArgumentAccess().getNameArgumentParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (calledFunction=[Function|ID] functionArgument+=FunctionArgument*)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDef returns FunctionDef
	 *
	 * Constraint:
	 *     (name=Function functionparam+=FunctionParam* CodeBlock=CodeBlock)
	 */
	protected void sequence_FunctionDef(ISerializationContext context, FunctionDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionParam returns FunctionParam
	 *
	 * Constraint:
	 *     (datatype=DataType name=ID)?
	 */
	protected void sequence_FunctionParam(ISerializationContext context, FunctionParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Goto returns Goto
	 *
	 * Constraint:
	 *     goto=[Label|QualifiedName]
	 */
	protected void sequence_Goto(ISerializationContext context, Goto semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.GOTO__GOTO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.GOTO__GOTO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGotoAccess().getGotoLabelQualifiedNameParserRuleCall_2_0_1(), semanticObject.eGet(GimpleDslPackage.Literals.GOTO__GOTO, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     If returns LogicalOperation
	 *
	 * Constraint:
	 *     (instruction+=Instruction | codeBlock+=CodeBlock)
	 */
	protected void sequence_If_LogicalOperation(ISerializationContext context, LogicalOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Instruction
	 *
	 * Constraint:
	 *     (
	 *         variableDeclaration=VariableDeclaration | 
	 *         varaibleCall=VariableCall | 
	 *         constantDelaration=ConstantDelaration | 
	 *         tempVariable=TempVariable | 
	 *         struct=Struct | 
	 *         LabelDef=LabelDef | 
	 *         switchLabelDef=SwitchLabelDef | 
	 *         goto=Goto | 
	 *         if=If | 
	 *         expressionTemporarie=ExpressionTemporarie | 
	 *         switchStatement=SwitchStatment | 
	 *         debugTag=DebugTag | 
	 *         functionCall=FunctionCall | 
	 *         assignOp=AssignOperation
	 *     )
	 */
	protected void sequence_Instruction(ISerializationContext context, Instruction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LabelDef returns LabelDef
	 *
	 * Constraint:
	 *     name=Label
	 */
	protected void sequence_LabelDef(ISerializationContext context, LabelDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.LABEL_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.LABEL_DEF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelDefAccess().getNameLabelParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Label returns Label
	 *
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.LABEL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     name=VARIABLE_INDENTIFIER
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.LOCAL_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.LOCAL_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalVariableAccess().getNameVARIABLE_INDENTIFIERParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns LogicalOperation
	 *     LogicalOperation returns LogicalOperation
	 *
	 * Constraint:
	 *     {LogicalOperation}
	 */
	protected void sequence_LogicalOperation(ISerializationContext context, LogicalOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StructVariableCall returns StructVariableCall
	 *
	 * Constraint:
	 *     calledStructVariable=[Struct|ID]
	 */
	protected void sequence_StructVariableCall(ISerializationContext context, StructVariableCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.STRUCT_VARIABLE_CALL__CALLED_STRUCT_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.STRUCT_VARIABLE_CALL__CALLED_STRUCT_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStructVariableCallAccess().getCalledStructVariableStructIDTerminalRuleCall_0_0_1(), semanticObject.eGet(GimpleDslPackage.Literals.STRUCT_VARIABLE_CALL__CALLED_STRUCT_VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Struct returns Struct
	 *
	 * Constraint:
	 *     (name=ID another=ID)
	 */
	protected void sequence_Struct(ISerializationContext context, Struct semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.STRUCT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.STRUCT__NAME));
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.STRUCT__ANOTHER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.STRUCT__ANOTHER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStructAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStructAccess().getAnotherIDTerminalRuleCall_4_0(), semanticObject.getAnother());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchCase returns SwitchCase
	 *
	 * Constraint:
	 *     (name=CASE_ID switchLabel=[SwitchLabel|QNSL])
	 */
	protected void sequence_SwitchCase(ISerializationContext context, SwitchCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.SWITCH_CASE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.SWITCH_CASE__NAME));
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.SWITCH_CASE__SWITCH_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.SWITCH_CASE__SWITCH_LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchCaseAccess().getNameCASE_IDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSwitchCaseAccess().getSwitchLabelSwitchLabelQNSLParserRuleCall_2_0_1(), semanticObject.eGet(GimpleDslPackage.Literals.SWITCH_CASE__SWITCH_LABEL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchDefaultCase returns SwitchDefaultCase
	 *
	 * Constraint:
	 *     (name='default' switchLabel=[SwitchLabel|QNSL])
	 */
	protected void sequence_SwitchDefaultCase(ISerializationContext context, SwitchDefaultCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.SWITCH_DEFAULT_CASE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.SWITCH_DEFAULT_CASE__NAME));
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.SWITCH_DEFAULT_CASE__SWITCH_LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.SWITCH_DEFAULT_CASE__SWITCH_LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchDefaultCaseAccess().getNameDefaultKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSwitchDefaultCaseAccess().getSwitchLabelSwitchLabelQNSLParserRuleCall_2_0_1(), semanticObject.eGet(GimpleDslPackage.Literals.SWITCH_DEFAULT_CASE__SWITCH_LABEL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchLabelDef returns SwitchLabelDef
	 *
	 * Constraint:
	 *     name=SwitchLabel
	 */
	protected void sequence_SwitchLabelDef(ISerializationContext context, SwitchLabelDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.SWITCH_LABEL_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.SWITCH_LABEL_DEF__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchLabelDefAccess().getNameSwitchLabelParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchLabel returns SwitchLabel
	 *
	 * Constraint:
	 *     name=QNSL
	 */
	protected void sequence_SwitchLabel(ISerializationContext context, SwitchLabel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.SWITCH_LABEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.SWITCH_LABEL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchLabelAccess().getNameQNSLParserRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStatment returns SwitchStatment
	 *
	 * Constraint:
	 *     (tempVariableRef=[TempVariable|TEMP_VARIABLE_PATTERN] switchDefaultCase+=SwitchDefaultCase SwitchCase1+=SwitchCase*)
	 */
	protected void sequence_SwitchStatment(ISerializationContext context, SwitchStatment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TAC returns TAC
	 *
	 * Constraint:
	 *     (functionDef+=FunctionDef | commentLine+=CommentLine)+
	 */
	protected void sequence_TAC(ISerializationContext context, TAC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TempVariable returns TempVariable
	 *
	 * Constraint:
	 *     name=TEMP_VARIABLE_PATTERN
	 */
	protected void sequence_TempVariable(ISerializationContext context, TempVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.TEMP_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.TEMP_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTempVariableAccess().getNameTEMP_VARIABLE_PATTERNTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableCall returns VariableCall
	 *
	 * Constraint:
	 *     calledVaraible=[LocalVariable|ID]
	 */
	protected void sequence_VariableCall(ISerializationContext context, VariableCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.VARIABLE_CALL__CALLED_VARAIBLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.VARIABLE_CALL__CALLED_VARAIBLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableCallAccess().getCalledVaraibleLocalVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(GimpleDslPackage.Literals.VARIABLE_CALL__CALLED_VARAIBLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (type=DataType name=LocalVariable)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.VARIABLE_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.VARIABLE_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, GimpleDslPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GimpleDslPackage.Literals.VARIABLE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getTypeDataTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameLocalVariableParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
